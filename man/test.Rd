% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/test.R
\name{test}
\alias{test}
\title{test}
\usage{
test(
  fun,
  arg,
  val,
  expect.error = NULL,
  parall = FALSE,
  thread.nb = NULL,
  print.count = 10,
  plot.fun = FALSE,
  export = FALSE,
  res.path = NULL,
  lib.path = NULL,
  cute.path =
    "C:/Users/yhan/Documents/Git_projects/cute_little_R_functions/cute_little_R_functions.R"
)
}
\arguments{
\item{fun}{Single character string indicating the name of the function tested (without brackets).}

\item{arg}{Vector of character strings of arguments of fun. At least arguments that do not have default values must be present in this vector.}

\item{val}{List with number of compartments equal to the length of arg, each compartment containing values of the corresponding argument in arg. Each different value must be in a list or in a vector. For instance, argument 3 in arg is a logical argument (values accepted TRUE, FALSE, NA). Thus, compartment 3 of val can be either list(TRUE, FALSE, NA), or c(TRUE, FALSE, NA). NULL value alone must be written list(NULL).}

\item{expect.error}{List of exactly the same structure as val argument, but containing FALSE or TRUE, depending on whether error is expected (TRUE) or not (FALSE) for each corresponding value of val. A message is returned depending on discrepancies between the expected and observed errors. See the examples below. BEWARE: not always possible to write the expected errors for all the combination of argument values. Ignored if NULL.}

\item{parall}{Single logical value. Force parallelization ?}

\item{thread.nb}{Single numeric integer indicating the number of threads to use if ever parallelization is required. If NULL, all the available threads will be used. Ignored if parall is FALSE.}

\item{print.count}{Single interger value. Print a working progress message every print.count during loops. BEWARE: can increase substentially the time to complete the process if using a small integer value, like 10 for instance. Use Inf if no loop message desired.}

\item{plot.fun}{Single logical value. Plot the plotting function tested for each test? Ignored if the tested function is not a graphic function.}

\item{export}{Single logical value. Export the results into a .RData file and into a .tsv file? If FALSE, return a list into the console (see below). BEWARE: will be automatically set to TRUE if parall is TRUE. This means that when using parallelization, the results are systematically exported, not returned into the console.}

\item{res.path}{Single character string indicating the absolute pathway of the folder where the txt results and pdfs, containing all the plots, will be saved. Several txt and pdf, one per thread, if parallelization. Ignored if export is FALSE. Must be specified if parall is TRUE or if export is TRUE.}

\item{lib.path}{Vector of characters specifying the absolute pathways of the directories containing the required packages if not in the default directories. Ignored if NULL.}

\item{cute.path}{Single character string indicating the absolute path of the cute.R file. Will be remove when cute will be a package. Ignored if parall is FALSE.}
}
\value{
One or several pdf if a plotting function is tested and if the plot.fun argument is TRUE. 

And then, if export is FALSE a list containing:
- $fun: the tested function.
- $ini: the initial input values.
- $data: a data frame of all the combination tested, containing the following columns:
     # the different values tested, named by arguments
     - $kind: a vector of character strings indicating the kind of test result: either "ERROR", or "WARNING", or "OK".
     - $problem: a logical vector indicating if error or not.
     - $expected.error: optional logical vector indicating the expected error specified in the expect.error argument.
     - $message: either NULL if $kind is always "OK", or the messages.
- $sys.info: system and packages info.

If export is TRUE:
- the same list object into a .RData file.
- also the $data data frame into a .tsv file.
- if expect.error is non NULL and if any discrepancy, the $data data frame into a .tsv file but containing only the rows with discrepancies between expected and observed errors.
}
\description{
Test combinations of argument values of a function.
}
\details{
REQUIRED PACKAGES

lubridate

parallel if parall argument is TRUE (included in the R installation packages but not automatically loaded)

pdftools if parall argument is TRUE (included in the R installation packages but not automatically loaded)

If the tested function is in a package, this package must be imported first (no parallelization) or must be in the classical R package folder indicated by the lib.path argument (parallelization)


REQUIRED FUNCTIONS FROM CUTE_LITTLE_R_FUNCTION

check()

get_message()

pack()


WARNINGS

Limited to 43 arguments with at least 2 values each. The total number of arguments tested can be more if the additional arguments have a single value. The limit is due to nested "for" loops (https://stat.ethz.ch/pipermail/r-help/2008-March/157341.html), but this limitation is away from the number of tests performed that would be 2^43.
}
\examples{
test(fun = "unique", arg = c("x", "incomparables"), 
val = list(x = list(1:10, c(1,1,2,8), NA), incomparable = c(TRUE, FALSE, NA)))

test(fun = "unique", arg = c("x", "incomparables"), 
val = list(x = list(1:10, c(1,1,2,8), NA), 
incomparable = c(TRUE, FALSE, NA)), expect.error = list(x = list(FALSE, FALSE, TRUE), 
incomparable = c(FALSE, FALSE, TRUE)))

test(fun = "unique", arg = c("x", "incomparables"), 
val = list(x = list(1:10, c(1,1,2,8), NA), incomparable = c(TRUE, FALSE, NA)), 
expect.error = list(x = list(FALSE, FALSE, TRUE), incomparable = c(FALSE, FALSE, TRUE)), 
export = TRUE, res.path = getwd())

test(fun = "round", arg = c("data", "dec.nb", "after.lead.zero"), 
val = list(L1 = list(c(1, 1.0002256, 1.23568), "a", NA), 
L2 = list(2, c(1,3), NA), L3 = c(TRUE, FALSE, NA)))

test(fun = "plot", arg = c("x", "y"), val = list(x = list(1:10, 12:13, NA, (1:10)^2), 
y = list(1:10, NA, NA)),  expect.error = list(x = list(FALSE, TRUE, TRUE, FALSE), 
y = list(FALSE, TRUE, TRUE)), parall = FALSE, thread.nb = NULL, plot.fun = TRUE, 
res.path = "C:\\\\Users\\\\yhan\\\\Desktop\\\\", lib.path = NULL)

test(fun = "plot", arg = c("x", "y"), val = list(x = list(1:10, 12:13, NA, 
(1:10)^2), y = list(1:10, NA, NA)), parall = FALSE, thread.nb = 4, 
plot.fun = TRUE, res.path = "C:\\\\Users\\\\yhan\\\\Desktop\\\\", 
lib.path = "C:\\\\Program Files\\\\R\\\\R-4.3.1\\\\library\\\\")

set.seed(1) ; 
obs1 <- data.frame(Time = c(rnorm(10), rnorm(10) + 2), Group1 = rep(c("G", "H"), each = 10), 
stringsAsFactors = TRUE) ; test(fun = "gg_boxplot", arg = c("data1", "y", "categ"), 
val = list(L1 = list(L1 = obs1), L2 = list(L1 = "Time"), L3 = list(L1 = "Group1")))

set.seed(1) ; 
obs1 <- data.frame(Time = c(rnorm(10), rnorm(10) + 2), Group1 = rep(c("G", "H"), each = 10), 
stringsAsFactors = TRUE) ; 
test(fun = "gg_boxplot", arg = c("data1", "y", "categ"), val = list(L1 = list(obs1), 
L2 = "Time", L3 = "Group1"), parall = FALSE, thread.nb = NULL, plot.fun = TRUE, 
res.path = "C:\\\\Users\\\\yhan\\\\Desktop\\\\", lib.path = "C:\\\\Program Files\\\\R\\\\R-4.3.1\\\\library\\\\")

library(ggplot2) ; test(fun = "geom_histogram", arg = c("data", "mapping"), 
val = list(x = list(data.frame(X = "a", stringsAsFactors = TRUE)), 
y = list(ggplot2::aes(x = X))), parall = FALSE, thread.nb = NULL, 
plot.fun = TRUE, res.path = "C:\\\\Users\\\\yhan\\\\Desktop\\\\", 
lib.path = "C:\\\\Program Files\\\\R\\\\R-4.3.1\\\\library\\\\") 
# BEWARE: ggplot2::geom_histogram does not work
}
